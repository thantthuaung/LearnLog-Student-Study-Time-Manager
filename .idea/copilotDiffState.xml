<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/data/AppDatabase.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/data/AppDatabase.java" />
              <option name="updatedContent" value="package com.example.learnlog.data;&#10;&#10;import androidx.room.Database;&#10;import androidx.room.RoomDatabase;&#10;import androidx.room.migration.Migration;&#10;import androidx.sqlite.db.SupportSQLiteDatabase;&#10;&#10;@Database(entities = {TaskEntity.class}, version = 2, exportSchema = false)&#10;public abstract class AppDatabase extends RoomDatabase {&#10;    public abstract TaskDao taskDao();&#10;&#10;    public static final Migration MIGRATION_1_2 = new Migration(1, 2) {&#10;        @Override&#10;        public void migrate(SupportSQLiteDatabase database) {&#10;            database.execSQL(&quot;CREATE TABLE IF NOT EXISTS `tasks` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `title` TEXT, `subject` TEXT, `dueAt` INTEGER, `priority` INTEGER NOT NULL, `status` TEXT, `progress` INTEGER NOT NULL, `completed` INTEGER NOT NULL, `notes` TEXT, `createdAt` INTEGER NOT NULL, `updatedAt` INTEGER NOT NULL)&quot;);&#10;        }&#10;    };&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/data/TaskDao.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/data/TaskDao.java" />
              <option name="updatedContent" value="package com.example.learnlog.data;&#10;&#10;import androidx.room.Dao;&#10;import androidx.room.Insert;&#10;import androidx.room.OnConflictStrategy;&#10;import androidx.room.Query;&#10;import androidx.room.Update;&#10;import kotlinx.coroutines.flow.Flow;&#10;import java.util.List;&#10;&#10;@Dao&#10;public interface TaskDao {&#10;    @Query(&quot;SELECT * FROM tasks&quot;)&#10;    Flow&lt;List&lt;TaskEntity&gt;&gt; getAll();&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insert(task: TaskEntity): Long;&#10;&#10;    @Update&#10;    suspend fun update(task: TaskEntity);&#10;&#10;    @Query(&quot;DELETE FROM tasks WHERE id = :id&quot;)&#10;    suspend fun delete(id: Long);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/data/TaskEntity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/data/TaskEntity.java" />
              <option name="updatedContent" value="package com.example.learnlog.data;&#10;&#10;import androidx.room.Entity;&#10;import androidx.room.PrimaryKey;&#10;&#10;@Entity(tableName = &quot;tasks&quot;)&#10;public class TaskEntity {&#10;    @PrimaryKey(autoGenerate = true)&#10;    public long id;&#10;    public String title;&#10;    public String subject;&#10;    public Long dueAt;&#10;    public int priority; // 0: low, 1: med, 2: high&#10;    public String status; // PENDING, IN_PROGRESS, COMPLETED&#10;    public int progress;&#10;    public boolean completed;&#10;    public String notes;&#10;    public long createdAt;&#10;    public long updatedAt;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/data/TaskRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/data/TaskRepository.java" />
              <option name="updatedContent" value="package com.example.learnlog.data;&#10;&#10;import com.example.learnlog.data.TaskDao;&#10;import com.example.learnlog.data.TaskEntity;&#10;import java.util.List;&#10;import javax.inject.Inject;&#10;import javax.inject.Singleton;&#10;import kotlinx.coroutines.flow.Flow;&#10;&#10;@Singleton&#10;public class TaskRepository {&#10;    private final TaskDao taskDao;&#10;&#10;    @Inject&#10;    public TaskRepository(TaskDao taskDao) {&#10;        this.taskDao = taskDao;&#10;    }&#10;&#10;    public Flow&lt;List&lt;TaskEntity&gt;&gt; getTasks() {&#10;        return taskDao.getAll();&#10;    }&#10;&#10;    public suspend fun insert(task: TaskEntity) {&#10;        taskDao.insert(task);&#10;    }&#10;&#10;    public suspend fun update(task: TaskEntity) {&#10;        taskDao.update(task);&#10;    }&#10;&#10;    public suspend fun delete(id: Long) {&#10;        taskDao.delete(id);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/data/UserPreferencesRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/data/UserPreferencesRepository.java" />
              <option name="updatedContent" value="package com.example.learnlog.data;&#10;&#10;import android.content.Context;&#10;import androidx.datastore.core.DataStore;&#10;import androidx.datastore.preferences.core.Preferences;&#10;import androidx.datastore.preferences.core.edit;&#10;import androidx.datastore.preferences.core.stringPreferencesKey;&#10;import androidx.datastore.preferences.preferencesDataStore;&#10;import com.example.learnlog.ui.tasks.TaskFilter;&#10;import com.example.learnlog.ui.tasks.TaskSort;&#10;import java.io.IOException;&#10;import javax.inject.Inject;&#10;import kotlinx.coroutines.flow.Flow;&#10;import kotlinx.coroutines.flow.catch;&#10;import kotlinx.coroutines.flow.map;&#10;&#10;public class UserPreferencesRepository {&#10;&#10;    private static final String USER_PREFERENCES_NAME = &quot;user_preferences&quot;;&#10;    private static final Context.Key&lt;DataStore&lt;Preferences&gt;&gt; PREFERENCES_KEY =&#10;            new Context.Key&lt;&gt;(USER_PREFERENCES_NAME);&#10;&#10;    private final DataStore&lt;Preferences&gt; dataStore;&#10;&#10;    private static final Preferences.Key&lt;String&gt; TASK_FILTER_KEY = stringPreferencesKey(&quot;task_filter&quot;);&#10;    private static final Preferences.Key&lt;String&gt; TASK_SORT_KEY = stringPreferencesKey(&quot;task_sort&quot;);&#10;&#10;    @Inject&#10;    public UserPreferencesRepository(Context context) {&#10;        this.dataStore = context.getDataStore();&#10;    }&#10;&#10;    public Flow&lt;TaskFilter&gt; getTaskFilter() {&#10;        return dataStore.data()&#10;                .catch((exception) -&gt; {&#10;                    if (exception instanceof IOException) {&#10;                        emit(Preferences.EMPTY);&#10;                    } else {&#10;                        throw exception;&#10;                    }&#10;                })&#10;                .map(preferences -&gt; {&#10;                    String filterName = preferences.get(TASK_FILTER_KEY);&#10;                    return filterName != null ? TaskFilter.valueOf(filterName) : TaskFilter.ALL;&#10;                });&#10;    }&#10;&#10;    public suspend fun setTaskFilter(filter: TaskFilter) {&#10;        dataStore.edit(preferences -&gt; {&#10;            preferences.set(TASK_FILTER_KEY, filter.name());&#10;            return null;&#10;        });&#10;    }&#10;&#10;    public Flow&lt;TaskSort&gt; getTaskSort() {&#10;        return dataStore.data()&#10;                .catch((exception) -&gt; {&#10;                    if (exception instanceof IOException) {&#10;                        emit(Preferences.EMPTY);&#10;                    } else {&#10;                        throw exception;&#10;                    }&#10;                })&#10;                .map(preferences -&gt; {&#10;                    String sortName = preferences.get(TASK_SORT_KEY);&#10;                    return sortName != null ? TaskSort.valueOf(sortName) : TaskSort.DUE_DATE;&#10;                });&#10;    }&#10;&#10;    public suspend fun setTaskSort(sort: TaskSort) {&#10;        dataStore.edit(preferences -&gt; {&#10;            preferences.set(TASK_SORT_KEY, sort.name());&#10;            return null;&#10;        });&#10;    }&#10;&#10;    private static final Context.Getter&lt;DataStore&lt;Preferences&gt;&gt; dataStoreGetter =&#10;            (context) -&gt; preferencesDataStore(USER_PREFERENCES_NAME).getValue(context, null);&#10;&#10;    private static Context.Key&lt;DataStore&lt;Preferences&gt;&gt; getDataStoreKey() {&#10;        return PREFERENCES_KEY;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/di/DataStoreModule.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/di/DataStoreModule.java" />
              <option name="updatedContent" value="package com.example.learnlog.di;&#10;&#10;import android.content.Context;&#10;import com.example.learnlog.data.UserPreferencesRepository;&#10;import dagger.Module;&#10;import dagger.Provides;&#10;import dagger.hilt.InstallIn;&#10;import dagger.hilt.android.qualifiers.ApplicationContext;&#10;import dagger.hilt.components.SingletonComponent;&#10;import javax.inject.Singleton;&#10;&#10;@Module&#10;@InstallIn(SingletonComponent.class)&#10;public class DataStoreModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    public UserPreferencesRepository provideUserPreferencesRepository(@ApplicationContext Context context) {&#10;        return new UserPreferencesRepository(context);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/di/DatabaseModule.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/di/DatabaseModule.java" />
              <option name="updatedContent" value="package com.example.learnlog.di;&#10;&#10;import android.content.Context;&#10;import androidx.room.Room;&#10;import com.example.learnlog.data.AppDatabase;&#10;import com.example.learnlog.data.TaskDao;&#10;import dagger.Module;&#10;import dagger.Provides;&#10;import dagger.hilt.InstallIn;&#10;import dagger.hilt.android.qualifiers.ApplicationContext;&#10;import dagger.hilt.components.SingletonComponent;&#10;import javax.inject.Singleton;&#10;&#10;@Module&#10;@InstallIn(SingletonComponent.class)&#10;public class DatabaseModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    public AppDatabase provideAppDatabase(@ApplicationContext Context context) {&#10;        return Room.databaseBuilder(context, AppDatabase.class, &quot;learnlog-db&quot;)&#10;                .fallbackToDestructiveMigration() // For dev; replace with proper migration for prod&#10;                .build();&#10;    }&#10;&#10;    @Provides&#10;    public TaskDao provideTaskDao(AppDatabase appDatabase) {&#10;        return appDatabase.taskDao();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/ui/tasks/AddEditTaskBottomSheet.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/ui/tasks/AddEditTaskBottomSheet.java" />
              <option name="updatedContent" value="package com.example.learnlog.ui.tasks;&#10;&#10;import android.app.DatePickerDialog;&#10;import android.app.TimePickerDialog;&#10;import android.os.Bundle;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.Toast;&#10;import androidx.annotation.Nullable;&#10;import androidx.fragment.app.viewModels;&#10;import com.example.learnlog.data.TaskEntity;&#10;import com.example.learnlog.databinding.DialogAddTaskBinding;&#10;import com.google.android.material.bottomsheet.BottomSheetDialogFragment;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Calendar;&#10;import java.util.Locale;&#10;&#10;public class AddEditTaskBottomSheet extends BottomSheetDialogFragment {&#10;&#10;    private DialogAddTaskBinding binding;&#10;    private final TasksViewModel viewModel;&#10;    private TaskEntity currentTask;&#10;    private Calendar dueDateTime = Calendar.getInstance();&#10;&#10;    public AddEditTaskBottomSheet(TasksViewModel viewModel, @Nullable TaskEntity task) {&#10;        this.viewModel = viewModel;&#10;        this.currentTask = task;&#10;        if (task != null &amp;&amp; task.dueAt != null) {&#10;            dueDateTime.setTimeInMillis(task.dueAt);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {&#10;        binding = DialogAddTaskBinding.inflate(inflater, container, false);&#10;        return binding.getRoot();&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(View view, Bundle savedInstanceState) {&#10;        super.onViewCreated(view, savedInstanceState);&#10;&#10;        if (currentTask != null) {&#10;            binding.titleInput.setText(currentTask.title);&#10;            binding.subjectInput.setText(currentTask.subject);&#10;            binding.notesInput.setText(currentTask.notes);&#10;            binding.priorityGroup.check(getPriorityChipId(currentTask.priority));&#10;            updateDateTimeFields();&#10;        }&#10;&#10;        binding.datePicker.setOnClickListener(v -&gt; showDatePicker());&#10;        binding.timePicker.setOnClickListener(v -&gt; showTimePicker());&#10;&#10;        binding.btnSave.setOnClickListener(v -&gt; saveTask());&#10;    }&#10;&#10;    private void showDatePicker() {&#10;        new DatePickerDialog(&#10;                requireContext(),&#10;                (view, year, month, dayOfMonth) -&gt; {&#10;                    dueDateTime.set(Calendar.YEAR, year);&#10;                    dueDateTime.set(Calendar.MONTH, month);&#10;                    dueDateTime.set(Calendar.DAY_OF_MONTH, dayOfMonth);&#10;                    updateDateTimeFields();&#10;                },&#10;                dueDateTime.get(Calendar.YEAR),&#10;                dueDateTime.get(Calendar.MONTH),&#10;                dueDateTime.get(Calendar.DAY_OF_MONTH)&#10;        ).show();&#10;    }&#10;&#10;    private void showTimePicker() {&#10;        new TimePickerDialog(&#10;                requireContext(),&#10;                (view, hourOfDay, minute) -&gt; {&#10;                    dueDateTime.set(Calendar.HOUR_OF_DAY, hourOfDay);&#10;                    dueDateTime.set(Calendar.MINUTE, minute);&#10;                    updateDateTimeFields();&#10;                },&#10;                dueDateTime.get(Calendar.HOUR_OF_DAY),&#10;                dueDateTime.get(Calendar.MINUTE),&#10;                false&#10;        ).show();&#10;    }&#10;&#10;    private void updateDateTimeFields() {&#10;        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;EEE, MMM d, yyyy&quot;, Locale.getDefault());&#10;        binding.datePicker.setText(dateFormat.format(dueDateTime.getTime()));&#10;        SimpleDateFormat timeFormat = new SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault());&#10;        binding.timePicker.setText(timeFormat.format(dueDateTime.getTime()));&#10;    }&#10;&#10;    private void saveTask() {&#10;        String title = binding.titleInput.getText().toString().trim();&#10;        if (title.isEmpty()) {&#10;            Toast.makeText(getContext(), &quot;Title cannot be empty&quot;, Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        String subject = binding.subjectInput.getText().toString().trim();&#10;        String notes = binding.notesInput.getText().toString().trim();&#10;        int priority = getPriorityFromChipId(binding.priorityGroup.getCheckedChipId());&#10;&#10;        if (currentTask == null) {&#10;            // New Task&#10;            TaskEntity newTask = new TaskEntity();&#10;            newTask.title = title;&#10;            newTask.subject = subject;&#10;            newTask.notes = notes;&#10;            newTask.priority = priority;&#10;            newTask.dueAt = dueDateTime.getTimeInMillis();&#10;            newTask.status = &quot;PENDING&quot;;&#10;            newTask.completed = false;&#10;            newTask.createdAt = System.currentTimeMillis();&#10;            newTask.updatedAt = System.currentTimeMillis();&#10;            viewModel.insert(newTask);&#10;        } else {&#10;            // Update Task&#10;            currentTask.title = title;&#10;            currentTask.subject = subject;&#10;            currentTask.notes = notes;&#10;            currentTask.priority = priority;&#10;            currentTask.dueAt = dueDateTime.getTimeInMillis();&#10;            currentTask.updatedAt = System.currentTimeMillis();&#10;            viewModel.update(currentTask);&#10;        }&#10;        dismiss();&#10;    }&#10;&#10;    private int getPriorityFromChipId(int chipId) {&#10;        if (chipId == binding.chipHigh.getId()) return 2;&#10;        if (chipId == binding.chipMedium.getId()) return 1;&#10;        return 0; // Low&#10;    }&#10;&#10;    private int getPriorityChipId(int priority) {&#10;        if (priority == 2) return binding.chipHigh.getId();&#10;        if (priority == 1) return binding.chipMedium.getId();&#10;        return binding.chipLow.getId();&#10;    }&#10;&#10;    @Override&#10;    public void onDestroyView() {&#10;        super.onDestroyView();&#10;        binding = null;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/ui/tasks/TaskFilter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/ui/tasks/TaskFilter.java" />
              <option name="updatedContent" value="package com.example.learnlog.ui.tasks;&#10;&#10;enum class TaskFilter {&#10;    ALL,&#10;    DUE,&#10;    COMPLETED&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/ui/tasks/TaskSort.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/ui/tasks/TaskSort.java" />
              <option name="updatedContent" value="package com.example.learnlog.ui.tasks;&#10;&#10;enum class TaskSort {&#10;    DUE_DATE,&#10;    PRIORITY,&#10;    TITLE&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/ui/tasks/TasksViewModel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/ui/tasks/TasksViewModel.java" />
              <option name="originalContent" value="&#10;&#10;    private final TaskRepository taskRepository;&#10;    private final UserPreferencesRepository userPreferencesRepository;&#10;&#10;    private final MutableStateFlow&lt;TaskFilter&gt; _taskFilter;&#10;    private final MutableStateFlow&lt;TaskSort&gt; _taskSort;&#10;&#10;    public final StateFlow&lt;List&lt;TaskEntity&gt;&gt; uiState;&#10;&#10;    @Inject&#10;    public TasksViewModel(TaskRepository taskRepository, UserPreferencesRepository userPreferencesRepository) {&#10;        this.taskRepository = taskRepository;&#10;        this.userPreferencesRepository = userPreferencesRepository;&#10;&#10;        _taskFilter = new MutableStateFlow&lt;&gt;(TaskFilter.ALL);&#10;        _taskSort = new MutableStateFlow&lt;&gt;(TaskSort.DUE_DATE);&#10;" />
              <option name="updatedContent" value="package com.example.learnlog.ui.tasks;&#10;&#10;import androidx.lifecycle.ViewModel;&#10;import androidx.lifecycle.viewModelScope;&#10;import com.example.learnlog.data.TaskEntity;&#10;import com.example.learnlog.data.TaskRepository;&#10;import com.example.learnlog.data.UserPreferencesRepository;&#10;import dagger.hilt.android.lifecycle.HiltViewModel;&#10;import javax.inject.Inject;&#10;import kotlinx.coroutines.flow.Flow;&#10;import kotlinx.coroutines.flow.MutableStateFlow;&#10;import kotlinx.coroutines.flow.StateFlow;&#10;import kotlinx.coroutines.flow.combine;&#10;import kotlinx.coroutines.launch;&#10;import java.util.List;&#10;&#10;@HiltViewModel&#10;public class TasksViewModel extends ViewModel {&#10;&#10;    private final TaskRepository taskRepository;&#10;    private final UserPreferencesRepository userPreferencesRepository;&#10;&#10;    private final MutableStateFlow&lt;TaskFilter&gt; _taskFilter;&#10;    private final MutableStateFlow&lt;TaskSort&gt; _taskSort;&#10;&#10;    public final StateFlow&lt;List&lt;TaskEntity&gt;&gt; uiState;&#10;&#10;    @Inject&#10;    public TasksViewModel(TaskRepository taskRepository, UserPreferencesRepository userPreferencesRepository) {&#10;        this.taskRepository = taskRepository;&#10;        this.userPreferencesRepository = userPreferencesRepository;&#10;&#10;        _taskFilter = new MutableStateFlow&lt;&gt;(TaskFilter.ALL);&#10;        _taskSort = new MutableStateFlow&lt;&gt;(TaskSort.DUE_DATE);&#10;&#10;        viewModelScope.launch(() -&gt; {&#10;            userPreferencesRepository.getTaskFilter().collect(filter -&gt; _taskFilter.setValue(filter));&#10;        });&#10;&#10;        viewModelScope.launch(() -&gt; {&#10;            userPreferencesRepository.getTaskSort().collect(sort -&gt; _taskSort.setValue(sort));&#10;        });&#10;&#10;        uiState = combine(&#10;                taskRepository.getTasks(),&#10;                _taskFilter,&#10;                _taskSort,&#10;                (tasks, filter, sort) -&gt; {&#10;                    return applyFilterAndSort(tasks, filter, sort);&#10;                }&#10;        ).stateIn(viewModelScope, kotlinx.coroutines.flow.SharingStarted.WhileSubscribed(5000), emptyList());&#10;    }&#10;&#10;    public void setFilter(TaskFilter filter) {&#10;        viewModelScope.launch(() -&gt; {&#10;            userPreferencesRepository.setTaskFilter(filter);&#10;        });&#10;    }&#10;&#10;    public void setSort(TaskSort sort) {&#10;        viewModelScope.launch(() -&gt; {&#10;            userPreferencesRepository.setTaskSort(sort);&#10;        });&#10;    }&#10;&#10;    public void toggleComplete(TaskEntity task, boolean completed) {&#10;        viewModelScope.launch(() -&gt; {&#10;            task.completed = completed;&#10;            task.status = completed ? &quot;COMPLETED&quot; : &quot;PENDING&quot;;&#10;            task.updatedAt = System.currentTimeMillis();&#10;            taskRepository.update(task);&#10;        });&#10;    }&#10;&#10;    public void delete(long id) {&#10;        viewModelScope.launch(() -&gt; {&#10;            taskRepository.delete(id);&#10;        });&#10;    }&#10;&#10;    public void insert(TaskEntity task) {&#10;        viewModelScope.launch(() -&gt; {&#10;            taskRepository.insert(task);&#10;        });&#10;    }&#10;&#10;    public void update(TaskEntity task) {&#10;        viewModelScope.launch(() -&gt; {&#10;            taskRepository.update(task);&#10;        });&#10;    }&#10;&#10;    public void reinsert(TaskEntity task) {&#10;        viewModelScope.launch(() -&gt; {&#10;            taskRepository.insert(task);&#10;        });&#10;    }&#10;&#10;    private List&lt;TaskEntity&gt; applyFilterAndSort(List&lt;TaskEntity&gt; tasks, TaskFilter filter, TaskSort sort) {&#10;        // Apply filter&#10;        List&lt;TaskEntity&gt; filteredTasks;&#10;        switch (filter) {&#10;            case DUE:&#10;                filteredTasks = tasks.stream().filter(t -&gt; !t.completed &amp;&amp; t.dueAt != null).collect(java.util.stream.Collectors.toList());&#10;                break;&#10;            case COMPLETED:&#10;                filteredTasks = tasks.stream().filter(t -&gt; t.completed).collect(java.util.stream.Collectors.toList());&#10;                break;&#10;            case ALL:&#10;            default:&#10;                filteredTasks = tasks;&#10;                break;&#10;        }&#10;&#10;        // Apply sort&#10;        switch (sort) {&#10;            case DUE_DATE:&#10;                return filteredTasks.stream().sorted((t1, t2) -&gt; Long.compare(t1.dueAt != null ? t1.dueAt : Long.MAX_VALUE, t2.dueAt != null ? t2.dueAt : Long.MAX_VALUE)).collect(java.util.stream.Collectors.toList());&#10;            case PRIORITY:&#10;                return filteredTasks.stream().sorted((t1, t2) -&gt; Integer.compare(t2.priority, t1.priority)).collect(java.util.stream.Collectors.toList()); // Desc&#10;            case TITLE:&#10;                return filteredTasks.stream().sorted((t1, t2) -&gt; t1.title.compareToIgnoreCase(t2.title)).collect(java.util.stream.Collectors.toList());&#10;            default:&#10;                return filteredTasks;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/ui/timer/TaskTimerBottomSheet.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/learnlog/ui/timer/TaskTimerBottomSheet.kt" />
              <option name="originalContent" value="package com.example.learnlog.ui.timer&#10;&#10;import android.content.Context&#10;import android.media.Ringtone&#10;import android.media.RingtoneManager&#10;import android.os.Bundle&#10;import android.os.CountDownTimer&#10;import android.os.Vibrator&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.view.WindowManager&#10;import androidx.fragment.app.viewModels&#10;import com.example.learnlog.R&#10;import com.example.learnlog.databinding.BottomSheetTaskTimerBinding&#10;import com.google.android.material.bottomsheet.BottomSheetDialogFragment&#10;import com.google.android.material.dialog.MaterialAlertDialogBuilder&#10;import com.google.android.material.snackbar.Snackbar&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import java.util.Locale&#10;&#10;@AndroidEntryPoint&#10;class TaskTimerBottomSheet : BottomSheetDialogFragment() {&#10;    private var _binding: BottomSheetTaskTimerBinding? = null&#10;    private val binding get() = _binding!!&#10;    private val viewModel: TimerViewModel by viewModels()&#10;&#10;    private var taskId: Long = -1L&#10;    private var taskTitle: String = &quot;&quot;&#10;    private var taskSubject: String? = null&#10;    private var initialDurationMinutes: Int = 25&#10;&#10;    private var currentDurationMs = 25 * 60 * 1000L&#10;    private var remainingMillis = currentDurationMs&#10;    private var countDownTimer: CountDownTimer? = null&#10;    private var isRunning = false&#10;    private var sessionStarted = false&#10;&#10;    private var vibrator: Vibrator? = null&#10;    private var ringtone: Ringtone? = null&#10;&#10;    companion object {&#10;        private const val ARG_TASK_ID = &quot;taskId&quot;&#10;        private const val ARG_TASK_TITLE = &quot;taskTitle&quot;&#10;        private const val ARG_TASK_SUBJECT = &quot;taskSubject&quot;&#10;        private const val ARG_DURATION_MINUTES = &quot;durationMinutes&quot;&#10;&#10;        fun newInstance(&#10;            taskId: Long,&#10;            taskTitle: String,&#10;            taskSubject: String?,&#10;            durationMinutes: Int = 25&#10;        ): TaskTimerBottomSheet {&#10;            return TaskTimerBottomSheet().apply {&#10;                arguments = Bundle().apply {&#10;                    putLong(ARG_TASK_ID, taskId)&#10;                    putString(ARG_TASK_TITLE, taskTitle)&#10;                    putString(ARG_TASK_SUBJECT, taskSubject)&#10;                    putInt(ARG_DURATION_MINUTES, durationMinutes)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        arguments?.let {&#10;            taskId = it.getLong(ARG_TASK_ID, -1L)&#10;            taskTitle = it.getString(ARG_TASK_TITLE, &quot;Focus Session&quot;)&#10;            taskSubject = it.getString(ARG_TASK_SUBJECT)&#10;            initialDurationMinutes = it.getInt(ARG_DURATION_MINUTES, 25)&#10;        }&#10;&#10;        currentDurationMs = initialDurationMinutes * 60 * 1000L&#10;        remainingMillis = currentDurationMs&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = BottomSheetTaskTimerBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        vibrator = requireContext().getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        val notificationUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)&#10;        ringtone = RingtoneManager.getRingtone(requireContext(), notificationUri)&#10;&#10;        setupUI()&#10;        setupControls()&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun setupUI() {&#10;        binding.textTaskTitle.text = taskTitle&#10;&#10;        if (taskSubject.isNullOrBlank()) {&#10;            binding.chipSubject.visibility = View.GONE&#10;        } else {&#10;            binding.chipSubject.visibility = View.VISIBLE&#10;            binding.chipSubject.text = taskSubject&#10;        }&#10;    }&#10;&#10;    private fun setupControls() {&#10;        // Start/Pause button&#10;        binding.btnStartPause.setOnClickListener {&#10;            if (isRunning) {&#10;                pauseTimer()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;&#10;        // Stop button&#10;        binding.btnStop.setOnClickListener {&#10;            stopTimer()&#10;        }&#10;&#10;        // Time adjustment&#10;        binding.btnIncrease.setOnClickListener {&#10;            if (!isRunning) {&#10;                adjustTime(5 * 60 * 1000L) // +5 minutes&#10;            }&#10;        }&#10;&#10;        binding.btnDecrease.setOnClickListener {&#10;            if (!isRunning) {&#10;                adjustTime(-1 * 60 * 1000L) // -1 minute&#10;            }&#10;        }&#10;&#10;        // Keep screen on toggle&#10;        binding.switchKeepScreenOn.setOnCheckedChangeListener { _, isChecked -&gt;&#10;            if (isChecked) {&#10;                dialog?.window?.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;            } else {&#10;                dialog?.window?.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startTimer() {&#10;        // Start session on first start&#10;        if (!sessionStarted) {&#10;            val durationMinutes = (currentDurationMs / 1000 / 60).toInt()&#10;            viewModel.startTimerSession(taskId, taskTitle, durationMinutes)&#10;            sessionStarted = true&#10;        }&#10;&#10;        isRunning = true&#10;        binding.btnStartPause.text = &quot;Pause&quot;&#10;        binding.btnStartPause.setIconResource(R.drawable.ic_pause)&#10;        binding.btnStop.visibility = View.VISIBLE&#10;        binding.btnIncrease.isEnabled = false&#10;        binding.btnDecrease.isEnabled = false&#10;&#10;        countDownTimer = object : CountDownTimer(remainingMillis, 1000) {&#10;            override fun onTick(millisUntilFinished: Long) {&#10;                remainingMillis = millisUntilFinished&#10;                updateDisplay()&#10;            }&#10;&#10;            override fun onFinish() {&#10;                onTimerComplete()&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun pauseTimer() {&#10;        isRunning = false&#10;        binding.btnStartPause.text = &quot;Resume&quot;&#10;        binding.btnStartPause.setIconResource(R.drawable.ic_play)&#10;        countDownTimer?.cancel()&#10;    }&#10;&#10;    private fun stopTimer() {&#10;        MaterialAlertDialogBuilder(requireContext())&#10;            .setTitle(&quot;Stop Timer?&quot;)&#10;            .setMessage(&quot;Are you sure you want to stop this timer session?&quot;)&#10;            .setPositiveButton(&quot;Stop&quot;) { _, _ -&gt;&#10;                completeSession(false)&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;, null)&#10;            .show()&#10;    }&#10;&#10;    private fun adjustTime(deltaMs: Long) {&#10;        val newDuration = (currentDurationMs + deltaMs).coerceIn(60 * 1000L, 180 * 60 * 1000L)&#10;        currentDurationMs = newDuration&#10;        remainingMillis = newDuration&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        val minutes = remainingMillis / 1000 / 60&#10;        val seconds = remainingMillis / 1000 % 60&#10;        binding.textCountdown.text = String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, minutes, seconds)&#10;&#10;        // Update progress&#10;        val progress = if (currentDurationMs &gt; 0) {&#10;            ((currentDurationMs - remainingMillis).toFloat() / currentDurationMs * 100).toInt()&#10;        } else 0&#10;        binding.progressCircle.progress = progress&#10;    }&#10;&#10;    private fun onTimerComplete() {&#10;        isRunning = false&#10;        remainingMillis = 0&#10;        updateDisplay()&#10;&#10;        // Play sound and vibrate&#10;        if (binding.switchSound.isChecked) {&#10;            ringtone?.play()&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            vibrator?.vibrate(500)&#10;        }&#10;&#10;        // Show completion dialog&#10;        showCompletionDialog()&#10;    }&#10;&#10;    private fun showCompletionDialog() {&#10;        MaterialAlertDialogBuilder(requireContext())&#10;            .setTitle(&quot;Great Work!&quot;)&#10;            .setMessage(&quot;You've completed your focus session. Would you like to mark this task as completed?&quot;)&#10;            .setPositiveButton(&quot;Mark Completed&quot;) { _, _ -&gt;&#10;                completeSession(true)&#10;            }&#10;            .setNegativeButton(&quot;Keep In Progress&quot;) { _, _ -&gt;&#10;                completeSession(false)&#10;            }&#10;            .setCancelable(false)&#10;            .show()&#10;    }&#10;&#10;    private fun completeSession(markTaskCompleted: Boolean) {&#10;        val actualDurationMinutes = ((currentDurationMs - remainingMillis) / 1000 / 60).toInt()&#10;        viewModel.completeTimerSession(actualDurationMinutes)&#10;&#10;        if (markTaskCompleted &amp;&amp; taskId != -1L) {&#10;            viewModel.markTaskCompleted(taskId)&#10;        }&#10;&#10;        // Show snackbar on parent view&#10;        val message = if (markTaskCompleted) {&#10;            &quot;Session saved • Task completed&quot;&#10;        } else {&#10;            &quot;Session saved&quot;&#10;        }&#10;&#10;        activity?.findViewById&lt;View&gt;(android.R.id.content)?.let { rootView -&gt;&#10;            Snackbar.make(rootView, message, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;&#10;        dismiss()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        countDownTimer?.cancel()&#10;&#10;        // Clean up screen on flag&#10;        dialog?.window?.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;&#10;        _binding = null&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.learnlog.ui.timer&#10;&#10;import android.content.Context&#10;import android.media.Ringtone&#10;import android.media.RingtoneManager&#10;import android.os.Bundle&#10;import android.os.CountDownTimer&#10;import android.os.Vibrator&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.view.WindowManager&#10;import androidx.fragment.app.viewModels&#10;import com.example.learnlog.R&#10;import com.example.learnlog.databinding.BottomSheetTaskTimerBinding&#10;import com.google.android.material.bottomsheet.BottomSheetDialogFragment&#10;import com.google.android.material.dialog.MaterialAlertDialogBuilder&#10;import com.google.android.material.snackbar.Snackbar&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import java.util.Locale&#10;&#10;@AndroidEntryPoint&#10;class TaskTimerBottomSheet : BottomSheetDialogFragment() {&#10;    private var _binding: BottomSheetTaskTimerBinding? = null&#10;    private val binding get() = _binding!!&#10;    private val viewModel: TimerViewModel by viewModels()&#10;&#10;    private var taskId: Long = -1L&#10;    private var taskTitle: String = &quot;&quot;&#10;    private var taskSubject: String? = null&#10;    private var initialDurationMinutes: Int = 25&#10;&#10;    private var currentDurationMs = 25 * 60 * 1000L&#10;    private var remainingMillis = currentDurationMs&#10;    private var countDownTimer: CountDownTimer? = null&#10;    private var actualStartTimeMillis: Long = 0 // Track actual wall-clock start time&#10;    private var isRunning = false&#10;    private var sessionStarted = false&#10;&#10;    private var vibrator: Vibrator? = null&#10;    private var ringtone: Ringtone? = null&#10;&#10;    companion object {&#10;        private const val ARG_TASK_ID = &quot;taskId&quot;&#10;        private const val ARG_TASK_TITLE = &quot;taskTitle&quot;&#10;        private const val ARG_TASK_SUBJECT = &quot;taskSubject&quot;&#10;        private const val ARG_DURATION_MINUTES = &quot;durationMinutes&quot;&#10;&#10;        fun newInstance(&#10;            taskId: Long,&#10;            taskTitle: String,&#10;            taskSubject: String?,&#10;            durationMinutes: Int = 25&#10;        ): TaskTimerBottomSheet {&#10;            return TaskTimerBottomSheet().apply {&#10;                arguments = Bundle().apply {&#10;                    putLong(ARG_TASK_ID, taskId)&#10;                    putString(ARG_TASK_TITLE, taskTitle)&#10;                    putString(ARG_TASK_SUBJECT, taskSubject)&#10;                    putInt(ARG_DURATION_MINUTES, durationMinutes)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        arguments?.let {&#10;            taskId = it.getLong(ARG_TASK_ID, -1L)&#10;            taskTitle = it.getString(ARG_TASK_TITLE, &quot;Focus Session&quot;)&#10;            taskSubject = it.getString(ARG_TASK_SUBJECT)&#10;            initialDurationMinutes = it.getInt(ARG_DURATION_MINUTES, 25)&#10;        }&#10;&#10;        currentDurationMs = initialDurationMinutes * 60 * 1000L&#10;        remainingMillis = currentDurationMs&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = BottomSheetTaskTimerBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        vibrator = requireContext().getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        val notificationUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)&#10;        ringtone = RingtoneManager.getRingtone(requireContext(), notificationUri)&#10;&#10;        setupUI()&#10;        setupControls()&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun setupUI() {&#10;        binding.textTaskTitle.text = taskTitle&#10;&#10;        if (taskSubject.isNullOrBlank()) {&#10;            binding.chipSubject.visibility = View.GONE&#10;        } else {&#10;            binding.chipSubject.visibility = View.VISIBLE&#10;            binding.chipSubject.text = taskSubject&#10;        }&#10;    }&#10;&#10;    private fun setupControls() {&#10;        // Start/Pause button&#10;        binding.btnStartPause.setOnClickListener {&#10;            if (isRunning) {&#10;                pauseTimer()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;&#10;        // Stop button&#10;        binding.btnStop.setOnClickListener {&#10;            stopTimer()&#10;        }&#10;&#10;        // Time adjustment&#10;        binding.btnIncrease.setOnClickListener {&#10;            if (!isRunning) {&#10;                adjustTime(5 * 60 * 1000L) // +5 minutes&#10;            }&#10;        }&#10;&#10;        binding.btnDecrease.setOnClickListener {&#10;            if (!isRunning) {&#10;                adjustTime(-1 * 60 * 1000L) // -1 minute&#10;            }&#10;        }&#10;&#10;        // Keep screen on toggle&#10;        binding.switchKeepScreenOn.setOnCheckedChangeListener { _, isChecked -&gt;&#10;            if (isChecked) {&#10;                dialog?.window?.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;            } else {&#10;                dialog?.window?.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startTimer() {&#10;        // Start session on first start&#10;        if (!sessionStarted) {&#10;            val durationMinutes = (currentDurationMs / 1000 / 60).toInt()&#10;            viewModel.startTimerSession(taskId, taskTitle, durationMinutes)&#10;            sessionStarted = true&#10;            actualStartTimeMillis = System.currentTimeMillis() // Record actual start time&#10;        }&#10;&#10;        isRunning = true&#10;        binding.btnStartPause.text = &quot;Pause&quot;&#10;        binding.btnStartPause.setIconResource(R.drawable.ic_pause)&#10;        binding.btnStop.visibility = View.VISIBLE&#10;        binding.btnIncrease.isEnabled = false&#10;        binding.btnDecrease.isEnabled = false&#10;&#10;        countDownTimer = object : CountDownTimer(remainingMillis, 1000) {&#10;            override fun onTick(millisUntilFinished: Long) {&#10;                remainingMillis = millisUntilFinished&#10;                updateDisplay()&#10;            }&#10;&#10;            override fun onFinish() {&#10;                onTimerComplete()&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun pauseTimer() {&#10;        isRunning = false&#10;        binding.btnStartPause.text = &quot;Resume&quot;&#10;        binding.btnStartPause.setIconResource(R.drawable.ic_play)&#10;        countDownTimer?.cancel()&#10;    }&#10;&#10;    private fun stopTimer() {&#10;        MaterialAlertDialogBuilder(requireContext())&#10;            .setTitle(&quot;Stop Timer?&quot;)&#10;            .setMessage(&quot;Are you sure you want to stop this timer session?&quot;)&#10;            .setPositiveButton(&quot;Stop&quot;) { _, _ -&gt;&#10;                completeSession(false)&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;, null)&#10;            .show()&#10;    }&#10;&#10;    private fun adjustTime(deltaMs: Long) {&#10;        val newDuration = (currentDurationMs + deltaMs).coerceIn(60 * 1000L, 180 * 60 * 1000L)&#10;        currentDurationMs = newDuration&#10;        remainingMillis = newDuration&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        val minutes = remainingMillis / 1000 / 60&#10;        val seconds = remainingMillis / 1000 % 60&#10;        binding.textCountdown.text = String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, minutes, seconds)&#10;&#10;        // Update progress&#10;        val progress = if (currentDurationMs &gt; 0) {&#10;            ((currentDurationMs - remainingMillis).toFloat() / currentDurationMs * 100).toInt()&#10;        } else 0&#10;        binding.progressCircle.progress = progress&#10;    }&#10;&#10;    private fun onTimerComplete() {&#10;        isRunning = false&#10;        remainingMillis = 0&#10;        updateDisplay()&#10;&#10;        // Play sound and vibrate&#10;        if (binding.switchSound.isChecked) {&#10;            ringtone?.play()&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            vibrator?.vibrate(500)&#10;        }&#10;&#10;        // Show completion dialog&#10;        showCompletionDialog()&#10;    }&#10;&#10;    private fun showCompletionDialog() {&#10;        MaterialAlertDialogBuilder(requireContext())&#10;            .setTitle(&quot;Great Work!&quot;)&#10;            .setMessage(&quot;You've completed your focus session. Would you like to mark this task as completed?&quot;)&#10;            .setPositiveButton(&quot;Mark Completed&quot;) { _, _ -&gt;&#10;                completeSession(true)&#10;            }&#10;            .setNegativeButton(&quot;Keep In Progress&quot;) { _, _ -&gt;&#10;                completeSession(false)&#10;            }&#10;            .setCancelable(false)&#10;            .show()&#10;    }&#10;&#10;    private fun completeSession(markTaskCompleted: Boolean) {&#10;        // Calculate actual elapsed time from wall-clock, not countdown timer&#10;        val actualElapsedMs = if (actualStartTimeMillis &gt; 0) {&#10;            System.currentTimeMillis() - actualStartTimeMillis&#10;        } else {&#10;            // Fallback to countdown calculation if start time wasn't set&#10;            currentDurationMs - remainingMillis&#10;        }&#10;        val actualDurationMinutes = (actualElapsedMs / 1000 / 60).toInt().coerceAtLeast(1)&#10;        &#10;        viewModel.completeTimerSession(actualDurationMinutes)&#10;&#10;        if (markTaskCompleted &amp;&amp; taskId != -1L) {&#10;            viewModel.markTaskCompleted(taskId)&#10;        }&#10;&#10;        // Show snackbar on parent view&#10;        val message = if (markTaskCompleted) {&#10;            &quot;Session saved • Task completed&quot;&#10;        } else {&#10;            &quot;Session saved&quot;&#10;        }&#10;&#10;        activity?.findViewById&lt;View&gt;(android.R.id.content)?.let { rootView -&gt;&#10;            Snackbar.make(rootView, message, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;&#10;        dismiss()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        countDownTimer?.cancel()&#10;&#10;        // Clean up screen on flag&#10;        dialog?.window?.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;&#10;        _binding = null&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>