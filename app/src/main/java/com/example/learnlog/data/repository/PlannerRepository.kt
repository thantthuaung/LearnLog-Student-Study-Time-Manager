package com.example.learnlog.data.repository

import com.example.learnlog.data.model.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import java.util.*
import kotlin.math.min

class PlannerRepository(private val tasksRepository: TasksRepository) {
    private val sessionsFlow = MutableStateFlow<List<StudySession>>(emptyList())

    init {
        // Add some sample sessions for demo
        addSampleSessions()
    }

    private fun addSampleSessions() {
        val calendar = Calendar.getInstance().apply {
            set(2025, Calendar.OCTOBER, 4) // Current date context
            set(Calendar.HOUR_OF_DAY, 9)
            set(Calendar.MINUTE, 0)
        }

        // Morning study session
        addSession(StudySession(
            id = 1,
            title = "Math Review",
            subject = "Mathematics",
            startTime = calendar.time,
            duration = 90,
            type = StudyType.ASSIGNMENT_WORK,
            relatedTaskId = 1
        ))

        // Afternoon session
        calendar.add(Calendar.HOUR_OF_DAY, 3)
        addSession(StudySession(
            id = 2,
            title = "Physics Lab Prep",
            subject = "Physics",
            startTime = calendar.time,
            duration = 60,
            type = StudyType.EXAM_PREP
        ))

        // Evening session
        calendar.add(Calendar.HOUR_OF_DAY, 4)
        addSession(StudySession(
            id = 3,
            title = "Math Assignment",
            subject = "Mathematics",
            startTime = calendar.time,
            duration = 120,
            type = StudyType.ASSIGNMENT_WORK
        ))
    }

    fun getSessionsForDay(date: Date): Flow<List<StudySession>> {
        return sessionsFlow.map { sessions ->
            sessions.filter { session ->
                isSameDay(session.startTime, date)
            }.sortedBy { it.startTime }
        }
    }

    fun getSessionsForWeek(startDate: Date): Flow<List<StudySession>> {
        return sessionsFlow.map { sessions ->
            sessions.filter { session ->
                isInSameWeek(session.startTime, startDate)
            }.sortedBy { it.startTime }
        }
    }

    suspend fun suggestStudySessions(): List<StudySession> {
        val suggestions = mutableListOf<StudySession>()
        val pendingTasks = tasksRepository.getAllTasks().first().filter {
            it.status != TaskStatus.COMPLETED
        }

        val calendar = Calendar.getInstance()

        for (task in pendingTasks) {
            // Calculate needed study time based on task complexity
            val totalNeededTime = when(task.priority) {
                TaskPriority.HIGH -> 180 // 3 hours
                TaskPriority.MEDIUM -> 120 // 2 hours
                TaskPriority.LOW -> 60 // 1 hour
            }

            // Split into multiple sessions if needed
            var remainingTime = totalNeededTime
            while (remainingTime > 0) {
                val sessionDuration = min(remainingTime, 90) // Max 90 minutes per session

                // Find next available time slot
                val availableSlot = findNextAvailableSlot(calendar.time, sessionDuration)

                if (availableSlot != null) {
                    suggestions.add(StudySession(
                        title = "Study for ${task.title}",
                        subject = task.subject,
                        startTime = availableSlot.startTime,
                        duration = sessionDuration,
                        type = when(task.type) {
                            TaskType.EXAM -> StudyType.EXAM_PREP
                            else -> StudyType.ASSIGNMENT_WORK
                        },
                        relatedTaskId = task.id,
                        isAutoGenerated = true
                    ))
                }

                remainingTime -= sessionDuration
                calendar.add(Calendar.DAY_OF_MONTH, 1) // Try next day if needed
            }
        }

        return suggestions
    }

    private fun findNextAvailableSlot(after: Date, durationNeeded: Int): TimeSlot? {
        val calendar = Calendar.getInstance().apply { time = after }
        val existingSessions = sessionsFlow.value

        // Try to find a slot in the next 7 days
        repeat(8) {
            // Try morning slot (9 AM)
            calendar.set(Calendar.HOUR_OF_DAY, 9)
            calendar.set(Calendar.MINUTE, 0)
            if (isTimeSlotAvailable(calendar.time, durationNeeded, existingSessions)) {
                return TimeSlot(calendar.time, addMinutes(calendar.time, durationNeeded))
            }

            // Try afternoon slot (2 PM)
            calendar.set(Calendar.HOUR_OF_DAY, 14)
            if (isTimeSlotAvailable(calendar.time, durationNeeded, existingSessions)) {
                return TimeSlot(calendar.time, addMinutes(calendar.time, durationNeeded))
            }

            // Try evening slot (7 PM)
            calendar.set(Calendar.HOUR_OF_DAY, 19)
            if (isTimeSlotAvailable(calendar.time, durationNeeded, existingSessions)) {
                return TimeSlot(calendar.time, addMinutes(calendar.time, durationNeeded))
            }

            calendar.add(Calendar.DAY_OF_MONTH, 1)
        }

        return null
    }

    private fun isTimeSlotAvailable(startTime: Date, duration: Int, existingSessions: List<StudySession>): Boolean {
        val endTime = addMinutes(startTime, duration)
        return existingSessions.none { session ->
            val sessionEnd = addMinutes(session.startTime, session.duration)
            !(endTime.before(session.startTime) || startTime.after(sessionEnd))
        }
    }

    fun addSession(session: StudySession) {
        val currentSessions = sessionsFlow.value.toMutableList()
        currentSessions.add(session)
        sessionsFlow.value = currentSessions
    }

    fun updateSession(session: StudySession) {
        val currentSessions = sessionsFlow.value.toMutableList()
        val index = currentSessions.indexOfFirst { it.id == session.id }
        if (index != -1) {
            currentSessions[index] = session
            sessionsFlow.value = currentSessions
        }
    }

    fun deleteSession(sessionId: Long) {
        val currentSessions = sessionsFlow.value.toMutableList()
        currentSessions.removeAll { it.id == sessionId }
        sessionsFlow.value = currentSessions
    }

    private fun isSameDay(date1: Date, date2: Date): Boolean {
        val cal1 = Calendar.getInstance().apply { time = date1 }
        val cal2 = Calendar.getInstance().apply { time = date2 }
        return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)
    }

    private fun isInSameWeek(date1: Date, weekStart: Date): Boolean {
        val cal1 = Calendar.getInstance().apply { time = date1 }
        val cal2 = Calendar.getInstance().apply { time = weekStart }
        return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR)
    }

    private fun addMinutes(date: Date, minutes: Int): Date {
        val calendar = Calendar.getInstance()
        calendar.time = date
        calendar.add(Calendar.MINUTE, minutes)
        return calendar.time
    }
}
