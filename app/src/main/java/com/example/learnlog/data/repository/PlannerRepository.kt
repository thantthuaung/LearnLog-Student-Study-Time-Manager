package com.example.learnlog.data.repository

import com.example.learnlog.data.model.*
import com.example.learnlog.util.DateTimeProvider
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import org.threeten.bp.LocalDateTime
import org.threeten.bp.ZoneId
import java.util.*
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.math.min

@Singleton
class PlannerRepository @Inject constructor(
    private val tasksRepository: TasksRepository,
    private val dateTimeProvider: DateTimeProvider
) {
    private val sessionsFlow = MutableStateFlow<List<StudySession>>(emptyList())

    init {
        // Add some sample sessions for demo
        addSampleSessions()
    }

    private fun addSampleSessions() {
        val baseDateTime = dateTimeProvider.now()
            .withHour(9)
            .withMinute(0)
            .withSecond(0)

        // Morning study session
        addSession(StudySession(
            id = 1,
            title = "Math Review",
            subject = "Mathematics",
            startTime = baseDateTime,
            endTime = baseDateTime.plusMinutes(90),
            durationMinutes = 90,
            type = StudyType.ASSIGNMENT_WORK,
            relatedTaskId = 1
        ))

        // Afternoon session (2 PM)
        val afternoonDateTime = baseDateTime.withHour(14)
        addSession(StudySession(
            id = 2,
            title = "Physics Lab Prep",
            subject = "Physics",
            startTime = afternoonDateTime,
            endTime = afternoonDateTime.plusMinutes(60),
            durationMinutes = 60,
            type = StudyType.EXAM_PREP
        ))

        // Evening session (7 PM)
        val eveningDateTime = baseDateTime.withHour(19)
        addSession(StudySession(
            id = 3,
            title = "Math Assignment",
            subject = "Mathematics",
            startTime = eveningDateTime,
            endTime = eveningDateTime.plusMinutes(120),
            durationMinutes = 120,
            type = StudyType.ASSIGNMENT_WORK
        ))
    }

    fun getSessionsForDay(date: LocalDateTime): Flow<List<StudySession>> {
        return sessionsFlow.map { sessions ->
            sessions.filter { session ->
                session.startTime.toLocalDate() == date.toLocalDate()
            }
        }
    }

    fun getSessionsForWeek(startDate: LocalDateTime): Flow<List<StudySession>> {
        val endDate = startDate.plusWeeks(1)
        return sessionsFlow.map { sessions ->
            sessions.filter { session ->
                val sessionDate = session.startTime
                !sessionDate.isBefore(startDate) && sessionDate.isBefore(endDate)
            }
        }
    }

    suspend fun suggestStudySessions(): List<StudySession> {
        val suggestions = mutableListOf<StudySession>()
        val pendingTasks = tasksRepository.getAllTasks().first().filter {
            it.status != TaskStatus.COMPLETED
        }

        val calendar = Calendar.getInstance()

        for (task in pendingTasks) {
            // Calculate needed study time based on task complexity
            val totalNeededTime = when(task.priority) {
                TaskPriority.HIGH -> 180 // 3 hours
                TaskPriority.MEDIUM -> 120 // 2 hours
                TaskPriority.LOW -> 60 // 1 hour
            }

            // Split into multiple sessions if needed
            var remainingTime = totalNeededTime
            while (remainingTime > 0) {
                val sessionDuration = min(remainingTime, 90) // Max 90 minutes per session

                // Find next available time slot
                val availableSlot = findNextAvailableSlot(
                    LocalDateTime.ofInstant(
                        org.threeten.bp.DateTimeUtils.toInstant(calendar),
                        ZoneId.systemDefault()
                    ),
                    sessionDuration
                )

                if (availableSlot != null) {
                    suggestions.add(StudySession(
                        id = 0,
                        title = "Study for ${task.title}",
                        subject = task.subject ?: "",
                        startTime = availableSlot.startTime,
                        endTime = availableSlot.endTime,
                        durationMinutes = sessionDuration,
                        type = when(task.type) {
                            TaskType.EXAM -> StudyType.EXAM_PREP
                            else -> StudyType.ASSIGNMENT_WORK
                        },
                        relatedTaskId = task.id,
                        isAutoGenerated = true
                    ))
                }

                remainingTime -= sessionDuration
                calendar.add(Calendar.DAY_OF_MONTH, 1) // Try next day if needed
            }
        }

        return suggestions
    }

    private fun findNextAvailableSlot(after: LocalDateTime, durationNeeded: Int): TimeSlot? {
        var currentTime = after
        val existingSessions = sessionsFlow.value

        // Try to find a slot in the next 7 days
        repeat(8) {
            // Try morning slot (9 AM)
            currentTime = currentTime.withHour(9).withMinute(0)
            if (isTimeSlotAvailable(currentTime, durationNeeded, existingSessions)) {
                return TimeSlot(currentTime, currentTime.plusMinutes(durationNeeded.toLong()))
            }

            // Try afternoon slot (2 PM)
            currentTime = currentTime.withHour(14)
            if (isTimeSlotAvailable(currentTime, durationNeeded, existingSessions)) {
                return TimeSlot(currentTime, currentTime.plusMinutes(durationNeeded.toLong()))
            }

            // Try evening slot (7 PM)
            currentTime = currentTime.withHour(19)
            if (isTimeSlotAvailable(currentTime, durationNeeded, existingSessions)) {
                return TimeSlot(currentTime, currentTime.plusMinutes(durationNeeded.toLong()))
            }

            currentTime = currentTime.plusDays(1)
        }

        return null
    }

    private fun isTimeSlotAvailable(startTime: LocalDateTime, duration: Int, existingSessions: List<StudySession>): Boolean {
        val endTime = startTime.plusMinutes(duration.toLong())
        return existingSessions.none { session ->
            val sessionEnd = session.startTime.plusMinutes(session.durationMinutes.toLong())
            !(endTime.isBefore(session.startTime) || startTime.isAfter(sessionEnd))
        }
    }

    fun addSession(session: StudySession) {
        val currentSessions = sessionsFlow.value.toMutableList()
        currentSessions.add(session)
        sessionsFlow.value = currentSessions
    }

    fun updateSession(session: StudySession) {
        val currentSessions = sessionsFlow.value.toMutableList()
        val index = currentSessions.indexOfFirst { it.id == session.id }
        if (index != -1) {
            currentSessions[index] = session
            sessionsFlow.value = currentSessions
        }
    }

    fun deleteSession(sessionId: Long) {
        val currentSessions = sessionsFlow.value.toMutableList()
        currentSessions.removeAll { it.id == sessionId }
        sessionsFlow.value = currentSessions
    }
}
