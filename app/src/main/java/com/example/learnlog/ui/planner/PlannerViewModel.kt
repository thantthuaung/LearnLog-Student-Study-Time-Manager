package com.example.learnlog.ui.planner

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.learnlog.data.model.CalendarMode
import com.example.learnlog.data.model.StudySession
import com.example.learnlog.data.model.SessionStatus
import com.example.learnlog.data.model.StudyType
import com.example.learnlog.data.repository.PlannerRepository
import com.example.learnlog.ui.tasks.TaskItem
import com.example.learnlog.ui.tasks.TaskType
import com.example.learnlog.util.DateTimeProvider
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import javax.inject.Inject
import org.threeten.bp.LocalDateTime

@HiltViewModel
class PlannerViewModel @Inject constructor(
    private val repository: PlannerRepository,
    private val dateTimeProvider: DateTimeProvider
) : ViewModel() {

    private val _plannerItems = MutableStateFlow<List<StudySession>>(emptyList())
    val plannerItems: StateFlow<List<StudySession>> = _plannerItems

    private val _calendarMode = MutableStateFlow(CalendarMode.WEEK)
    val calendarMode: StateFlow<CalendarMode> = _calendarMode

    init {
        loadTasks(emptyList())
    }

    fun loadTasks(tasks: List<TaskItem> = emptyList()) {
        viewModelScope.launch {
            // Convert TaskItems to study sessions
            val sessions = tasks.map { task ->
                StudySession(
                    id = task.id,
                    title = task.title,
                    subject = task.subject,
                    startTime = task.dueDateTime.minusHours(2),
                    endTime = task.dueDateTime,
                    durationMinutes = 120,
                    type = when (task.type) {
                        TaskType.EXAM -> StudyType.EXAM_PREP
                        TaskType.REVISION -> StudyType.REVISION
                        else -> StudyType.ASSIGNMENT_WORK
                    },
                    relatedTaskId = task.id,
                    isAutoGenerated = true,
                    status = SessionStatus.PENDING
                )
            }
            _plannerItems.value = sessions
        }
    }

    fun addManualSession(session: StudySession) {
        _plannerItems.value = _plannerItems.value + session.copy(id = nextSessionId++, isAutoGenerated = true)
    }

    fun rescheduleSession(sessionId: Long, newStart: LocalDateTime, newEnd: LocalDateTime) {
        _plannerItems.value = _plannerItems.value.map { session ->
            if (session.id == sessionId) {
                session.copy(startTime = newStart, endTime = newEnd)
            } else {
                session
            }
        }
    }

    fun markSessionCompleted(sessionId: Long) {
        viewModelScope.launch {
            val currentSessions = _plannerItems.value.toMutableList()
            val index = currentSessions.indexOfFirst { it.id == sessionId }
            if (index != -1) {
                val updatedSession = currentSessions[index].copy(status = SessionStatus.COMPLETED)
                currentSessions[index] = updatedSession
                _plannerItems.value = currentSessions
                repository.updateSession(updatedSession)
            }
        }
    }

    fun markSessionSkipped(sessionId: Long) {
        viewModelScope.launch {
            val currentSessions = _plannerItems.value.toMutableList()
            val index = currentSessions.indexOfFirst { it.id == sessionId }
            if (index != -1) {
                val updatedSession = currentSessions[index].copy(status = SessionStatus.SKIPPED)
                currentSessions[index] = updatedSession
                _plannerItems.value = currentSessions
                repository.updateSession(updatedSession)
            }
        }
    }

    fun setCalendarMode(mode: CalendarMode) {
        _calendarMode.value = mode
        viewModelScope.launch {
            _plannerItems.value = when (mode) {
                CalendarMode.DAY -> repository.getSessionsForDay(dateTimeProvider.now()).first()
                CalendarMode.WEEK -> repository.getSessionsForWeek(dateTimeProvider.now()).first()
                CalendarMode.MONTH -> emptyList() // Not implemented yet
            }
        }
    }

    companion object {
        private var nextSessionId = 1L
    }
}
